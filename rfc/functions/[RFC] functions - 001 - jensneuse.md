# Functions

## Problem

Currently, it's only possible to create Operations by creating `.graphql` files in the `.wundergraph/operations`
directory.
Additionally, Operations and hooks are not co-located.
Hooks are currently located in `wundergraph.server.ts`.
Operations are configured in `wundergraph.operations.ts`.
On top of that, it's allowed to use folders to organize operations, which folders are not reflected in the URL of the
operation, nor in the generated types.
This means, you'll easily run into conflicts when you have two operations with the same name in different folders.

That said, there's another big drawback with the current approach.
You're only able to create operations by defining GraphQL Operations.
This means, the frontend contract will always depend on types from the virtual Graph.
While quite efficient in most use cases,
there are situations where you'd like to have clear abstraction between public and internal APIs,
or you might just want to define custom business logic without depending on one single Operation from the virtual Graph.

To sum up the problems:

1. Operations can only be defined using GraphQL
2. Hooks and Operations configuration are not co-located
3. folders are not reflected in the URL of the operation, nor in the generated types
4. you're only able to create operations by defining GraphQL Operations
5. you cannot define an Operation with pure business logic that doesn't depend on the virtual Graph
6. the configuration of an Operation is shared across a GraphQL file, the `wundergraph.operations.ts` file and
   the `wundergraph.server.ts` file
7. both `wundergraph.operations.ts` and `wundergraph.server.ts` will grow in size over time and become hard to maintain

## Solution

Folders will be reflected in the URL of the operation, and in the generated types.

Given the following folder structure:

```
.wundergraph
├── operations
│   ├── users
│   │   ├── create.graphql
│   │   ├── delete.graphql
│   │   ├── get.graphql
│   │   └── update.graphql
│   └── posts
│       ├── create.graphql
│       ├── delete.graphql
│       ├── get.graphql
│       └── update.graphql
```

The following endpoints will be created:

```
/operations/users/create
/operations/users/delete
/operations/users/get
/operations/users/update

/operations/posts/create
/operations/posts/delete
/operations/posts/get
/operations/posts/update
```

Calling the users/create Operation from the TypeScript client will look like this:

```ts
const out = await client.mutate({
  operationName: 'users/create',
  input: {
    name: 'Jens',
    bio: 'Founder@WunderGraph',
    email: 'jens@wundergraph.com',
    title: 'Welcome to WunderGraph!',
    content: 'This is WunderGraph =)',
    published: true,
  },
});
```

We simply use the full path (excluding the "/operations/" prefix) to create the URL and the operationName, instead of
just using the filename.

This solves problem "3".

Next, let's say we'd like to add hooks to the users/create Operation to set the input name to uppercase.

We'd extend the existing folder structure by adding a `create.hooks.ts` file:

```
.wundergraph
├── operations
│   ├── users
│   │   ├── create.graphql
│   │   ├── create.hooks.ts
```

In the `create.hooks.ts` file, we'd define the hooks for the users/create Operation:

```ts
import { configureHooks } from '../../generated/hooks/users/create';

export default configureHooks({
  mutatingPreResolve: async ({ input, context }) => {
    return {
      input: {
        ...input,
        name: input.name.toUpperCase(),
      },
    };
  },
});
```

The `configureHooks` function is auto generated by parsing the GraphQL file (in this case `create.graphql`) and updating
the folder structure in `/generated/hooks/users/create.ts`.
The CLI `wunderctl up` will detect changes to the file system (in this case `create.hooks.ts`) and updates the
configuration so that the gateway knows about the hooks.
Additionally, the hook is registered in the fastify hook server so it can be called from the gateway.

Next, we're looking at completely replacing the GraphQL layer with pure functions.

For this, we'll remove the `create.graphql` and `create.hooks.ts` files and add a `create.ts` file.
The filesystem will look like this:

```
.wundergraph
├── operations
│   ├── users
│   │   ├── create.ts
```

The route for this operation will be `/operations/users/create`.

The `create.ts` file will look like this:

```ts
import { createOperation } from '../../generated/functions';

const user = z.object({
  id: z.string(),
  name: z.string(),
  bio: z.string(),
  email: z.string(),
  title: z.string(),
  content: z.string(),
  published: z.boolean(),
});

const createUser = user.omit({ id: true });

export default createOperation({
  input: createUser,
  output: user,
  type: 'mutation',
  handler: async ({ input, context }) => {
    const id = uuid();
    const user = {
      ...input,
      id,
    };
    await context.db.users.insert(user);
    return user;
  },
});
```

Next, let's create an admin operation to delete a user.
This operation requires the user to be authenticated.
The user must have the role `admin` to be able to delete a user.

We'll add a `delete.ts` file to the `users` folder:

```
.wundergraph
├── operations
│   ├── users
│   │   ├── create.ts
│   │   ├── delete.ts
```

The `delete.ts` file will look like this:

```ts
import { createOperation } from '../../generated/functions';

const input = z.object({
  id: z.string(),
});

const output = z.object({
  deleted: z.boolean(),
});

export default createOperation({
  input,
  output,
  type: 'mutation',
  requiresAuth: true,
  handler: async ({ input, context }) => {
    if (!context.user.roles.includes('admin')) {
      throw new Error('Not authorized');
    }
    const { id } = input;
    const user = await context.db.users.findOne({ id });
    if (!user) {
      throw new Error('User not found');
    }
    await context.db.users.delete({ id });
    return true;
  },
});
```

As we're making use of the `db` object on the context, we need to create a context factory to inject the `db` object
into the context.

We'll add a `wundergraph.context.ts` file to the `.wundergraph` folder:

```
.wundergraph
├── operations
│   ├── users
│   │   ├── create.ts
│   │   ├── delete.ts
├── wundergraph.context.ts
```

The `wundergraph.context.ts` file will look like this:

It creates a global context object on application start,
and has an additional handler to inject per-request meta data into the context.

```ts
import { createContext } from '@wundergraph/sdk/functions';

export default createContext({
  global: async () => {
    const db = await connectToDatabase();
    return {
      db,
    };
  },
  request: async ({ request }) => {
    const user = await getUserFromRequest(request);
    return {
      user,
    };
  },
});
```

Finally, let's call the delete operation from the TypeScript client:

```ts
const out = await client.mutate({
  operationName: 'users/delete',
  input: {
    id: '123',
  },
});
```

Next, let's add a query to get the current user:

```
.wundergraph
├── operations
│   ├── users
│   │   ├── create.ts
│   │   ├── delete.ts
│   │   ├── get.ts
├── wundergraph.context.ts
```

The `get.ts` file will look like this:

```ts
import { createOperation } from '../../generated/functions';

const output = z.object({
  id: z.string(),
  name: z.string(),
  bio: z.string(),
  email: z.string(),
  title: z.string(),
  content: z.string(),
  published: z.boolean(),
});

export default createOperation({
  output,
  type: 'query',
  requiresAuth: true,
  handler: async ({ input, context }) => {
    const user = await context.db.users.findOne({ id: context.user.id });
    if (!user) {
      throw new Error('User not found');
    }
    return user;
  },
});
```
